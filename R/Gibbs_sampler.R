#' Gibbs sampler used to draw samples from the posterior distribution of parameters in HDP model for metabolite effects. The output can be saved for future prediction without having to recalculate it.
#'
#' @param data A list contains the input. It can be generated by function 'prepareData'.
#' @param Iter A integer specifying the total number of iterations.
#' @param record A integer specifying the iteration at which the function starts recording Gibbs samples.
#'
#' @return A list of length K, containing the Gibbs samples of each factor.
#' @export
#'
#' @examples
HDP_Gibbs <- function(data,Iter=1000,record=501){
  IDs = data$metabolites
  K = ncol(data$L)
  Result = list()
  for (k.latent in 1:K) {
    {alpha1_mu <- 2;alpha2_mu <- 2
    alpha1.a <- 5;alpha1.b <- 1;alpha2.a <- 5;alpha2.b <- 1
    p.outlier.alpha <- 1/5;p.outlier.beta <- 999/5
    p.0 <- 0.1;p.00 <- 0.01

    p.0s <- vector();p.00s <- vector();p.out <- vector()

    p <- dim(data$L)[1]
    alpha.grid <- c(seq(0.1,1,0.1),c(1:10) )
    taus <- sort(unique(c(seq(0.05,0.2,0.05),seq(0.2,1,0.1),seq(1,3,0.2),seq(3,5,0.5))))
    x <- ML.gamma(data = data,k.latent = k.latent,var.threshold = 1e-3)
    p.taus <- dgamma(x = taus^2,shape = x$shape,rate = x$rate);p.taus <- p.taus/sum(p.taus)
    # plot(taus,p.taus);p.taus[taus==3]
    alpha.tau <- rep(1/length(taus), length(taus) )
    gamma.tau <- 1/2
    b.l <- ((range(data$L[,k.latent])-mean(data$L[,k.latent]))*1.25+mean(data$L[,k.latent]))[1]
    b.u <- ((range(data$L[,k.latent])-mean(data$L[,k.latent]))*1.25+mean(data$L[,k.latent]))[2]

    w <- exp(seq(0.01,2,0.2))-1
    p.w <- dcauchy(x = w,location = 0,scale = 1)
    p.w <- p.w/sum(p.w)
    pathways <- listOfPathway(data = data$metabolites,supname = "SUPER_PATHWAY",subname ="SUB_PATHWAY",L.hat=data$L,var.g = data$var,k=k.latent)
    J <- length(pathways)
    Dishes <- list();Dish.assign <- list()
    dishes <- InitDishes()
    restaurants <- InitRestaurants(pathways = pathways)
    clusters <- InitClusters(pathways = pathways)
    M_k <- matrix(data = 0,nrow = J);M_k <- M_k[,-1]#number of tables serving dish k
    }
    {Num.K <- vector();Num.T <- vector()
      updateAlpha <- 1;p.outlier <- 0.001;init <- 1
      # if(init==1){
      #   Taus.counts <- matrix(data = 0,nrow = Iter-record+1,ncol = length(taus))
      # }
      Mus <- matrix(data = 0,nrow = Iter-record+1,ncol = nrow(data$metabolites))
      #SDs <- matrix(data = 0,nrow = Iter-record+1,ncol = nrow(data$metabolites))
      Community <- matrix(data = 0,nrow = length(unique(IDs$SUB_PATHWAY)),ncol = length(unique(IDs$SUB_PATHWAY)))
      clusterAssignments <- array(data = NA,dim = c(length(unique(IDs$SUB_PATHWAY)),length(unique(IDs$SUB_PATHWAY)),Iter-record+1))
      Mu.g <- matrix(data = 0,nrow = Iter-record+1,ncol = length(unique(IDs$SUB_PATHWAY)))
      Sigma.g <- matrix(data = 0,nrow = Iter-record+1,ncol = length(unique(IDs$SUB_PATHWAY)))
      postL <- matrix(data = 0,nrow = Iter-record+1,ncol = nrow(data$metabolites))
      postL2 <- matrix(data = 0,nrow = Iter-record+1,ncol = nrow(data$metabolites))
      PCHs <- matrix(data = 0,nrow = Iter,ncol = nrow(data$metabolites))
      num.clusters <- vector()
      MAF <- F

      Alphas.sup <- vector();Alphas.sub <- vector()

      if(MAF==T){likeli.joint <- vector()}
      #p.taus <- (colSums(Taus.counts)+nrow(Taus.counts)/length(taus))/(sum(Taus.counts)+nrow(Taus.counts))
      for (iter in 1:Iter) {
        code.block = 1
        for (j in 1:J) {
          for (g in 1:length(pathways[[j]])) {
            for (m in sample(x = c(1:pathways[[j]][[g]]$Mg),size = pathways[[j]][[g]]$Mg,replace = FALSE)) {
              #j <- 1;g <- 1;m <- 1
              #j <- 5;g <- 23;m <- 1
              #j <- 8;g <- 7;m <- 50
              #assign m to a cluster with the majority or the cluster of outliers
              #abcd <- update.abcd(clusters);a <- abcd$a;b <- abcd$b;c <- abcd$c;d <- abcd$d
              m.is.outlier <- is.outlier(pathways = pathways,j = j,g = g,m = m,p.outlier = p.outlier,alpha1_mu = alpha1_mu,alpha2_mu = alpha2_mu,clusters = clusters,restaurants = restaurants,dishes = dishes,M_k = M_k,N_t = N_t,N_c = N_c,w=w,p.w=p.w,taus = taus,p.taus = p.taus,p.00 = p.00,p.0 = p.0,b.l = b.l,b.u = b.u)
              #c.m <- 2
              pathways[[j]][[g]]$z[m] <- m.is.outlier
              pathways[[j]][[g]]$c[m] <- 1-m.is.outlier
              PCHs[iter,pathways[[j]][[g]]$indices[m]] <- m.is.outlier
              pathways[[j]][[g]]$t[m] <- 0;pathways[[j]][[g]]$k[m] <- 0
              #if m is not an outlier
              if(!m.is.outlier){
                c.m <- 1
                if( !(c.m%in%clusters[[j]][[g]][,1]) ){
                  #assign table for cluster c
                  t_c <- sample_t_c(pathways = pathways,j = j,g = g,c.m = c.m,alpha1_mu = alpha1_mu,alpha2_mu = alpha2_mu,restaurants = restaurants,dishes = dishes,clusters=clusters,M_k = M_k,taus = taus,p.taus = p.taus,p.00 = p.00,p.0 = p.0,w = w,p.w = p.w)
                  #if t is new
                  if(!(t_c%in%restaurants[[j]][,1])){
                    #sample dish for new table
                    k_for_t.new <- kForNewTable4(j = j,dishes = dishes,L = pathways[[j]][[g]]$Lgm.hat[m],var.m = pathways[[j]][[g]]$var.gm[m],taus = taus,p.taus =p.taus,M_k = M_k,alpha1_mu = alpha1_mu,alpha2_mu = alpha2_mu,w = w,p.w = p.w,p.00 = p.00,p.0 = p.0)
                    #if k is new
                    if(!(k_for_t.new%in%dishes[,1])){
                      #sample a new parameter
                      mu.sigma.new <- new.parameter(L = pathways[[j]][[g]]$Lgm.hat[m],var.m = pathways[[j]][[g]]$var.gm[m],taus = taus,p.taus = p.taus,w = w,p.w = p.w,p.00 = p.00,p.0 = p.0)
                      mu_new <- mu.sigma.new$mu;sigma_new <- mu.sigma.new$sigma
                      dishes <- rbind(dishes, c(k_for_t.new,mu_new,sigma_new) )
                    }
                    restaurants[[j]] <- rbind(restaurants[[j]], c(t_c,k_for_t.new,dishes[dishes[,1]==k_for_t.new,2],dishes[dishes[,1]==k_for_t.new,3]) )
                    M_k <- updateM_k(dishes,M_k,j,restaurants)
                  }
                  clusters[[j]][[g]] <- rbind( clusters[[j]][[g]],c(c.m,t_c,restaurants[[j]][restaurants[[j]][,1]==t_c,2],restaurants[[j]][restaurants[[j]][,1]==t_c,3],restaurants[[j]][restaurants[[j]][,1]==t_c,4]) )
                }
                #update model parameters
                pathways[[j]][[g]]$t[m] <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,2]
                pathways[[j]][[g]]$k[m] <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,3]
                pathways[[j]][[g]]$mu[m] <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,4]
                pathways[[j]][[g]]$sigma_g[m] <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,5]
                #remove empty clusters
                clusters.to.remove <- setdiff(clusters[[j]][[g]][,1],pathways[[j]][[g]]$c)
                if(length(clusters.to.remove)>0){
                  clusters[[j]][[g]] <- clusters[[j]][[g]][-which(clusters[[j]][[g]][,1] %in%  clusters.to.remove ),]
                  if(is.vector(clusters[[j]][[g]])){
                    clusters[[j]][[g]] <- matrix(data = clusters[[j]][[g]],ncol = 5)
                    colnames(clusters[[j]][[g]]) <- c("cluster","table","dish","mu","sigma")
                  }
                }
                #update relevant parameters
                # if(init==1){
                #   taus.counts <- updataTauCounts2(taus,clusters,pathways)
                #   p.taus <- (taus.counts+1/length(taus))/(sum(taus.counts)+1)
                # }
                # abcd <- update.abcd(clusters);a <- abcd$a;b <- abcd$b;c <- abcd$c;d <- abcd$d
              }
            }
            #remove empty tables
            tables.to.remove <- setdiff(restaurants[[j]][,1],unique(unlist(sapply(pathways[[j]], function(g){g$t}))))
            if(length(tables.to.remove)>0){
              restaurants[[j]] <- restaurants[[j]][-which(restaurants[[j]][,1]%in% tables.to.remove),]
              if(is.vector(restaurants[[j]])){
                restaurants[[j]] <- matrix(data = restaurants[[j]],ncol =4)
                colnames(restaurants[[j]]) <- c("table","dish","mu","sigma")
              }
            }
            M_k <- updateM_k(dishes,M_k,j,restaurants)
            #remove unused dishes
            dishes.to.remove <- which(colSums(M_k)==0)
            if(length(dishes.to.remove)>0){
              M_k <- M_k[,-dishes.to.remove]
              dishes <- dishes[-dishes.to.remove,]
              if(is.vector(dishes)){
                dishes <- matrix(data = dishes,ncol = 3)
                colnames(dishes) <- c("k","mu","sigma")
                M_k <- matrix(data = M_k,nrow = J)
                colnames(M_k) <- dishes[,1]
              }
            }
          }
        }

        code.block = 2
        # update table assignments for clusters
        for (j in 1:J) {
          for (g in 1:length(pathways[[j]])) {
            #j <- 5;g <- 23
            if (sum(pathways[[j]][[g]]$c)>0) {
              t_c <- sample_t_c(pathways = pathways,j = j,g = g,c.m = c.m,alpha1_mu = alpha1_mu,alpha2_mu = alpha2_mu,restaurants = restaurants,dishes = dishes,clusters=clusters,M_k = M_k,taus = taus,p.taus = p.taus,p.00 = p.00,p.0 = p.0,w = w,p.w = p.w)
              #t_c <- nextIndix(restaurants[[j]][,1])
              L <- pathways[[j]][[g]]$Lgm.hat[pathways[[j]][[g]]$c==c.m]
              var.m <- pathways[[j]][[g]]$var.gm[pathways[[j]][[g]]$c==c.m]
              #if t is new
              if(!(t_c%in%restaurants[[j]][,1])){
                #sample dish for new table
                k_for_t.new <- kForNewTable4(j = j,dishes = dishes,L = L,var.m = var.m,taus = taus,p.taus =p.taus,M_k = M_k,alpha1_mu = alpha1_mu,alpha2_mu = alpha2_mu,w = w,p.w = p.w,p.00 = p.00,p.0 = p.0)
                #if k is new
                if(!(k_for_t.new%in%dishes[,1])){
                  #sample a new parameter
                  mu.sigma.new <- new.parameter(L = L,var.m = var.m,taus = taus,p.taus = p.taus,w = w,p.w = p.w,p.00 = p.00,p.0 = p.0)
                  mu_new <- mu.sigma.new$mu;sigma_new <- mu.sigma.new$sigma
                  dishes <- rbind(dishes, c(k_for_t.new,mu_new,sigma_new) )
                }
                restaurants[[j]] <- rbind(restaurants[[j]], c(t_c,k_for_t.new,dishes[dishes[,1]==k_for_t.new,2],dishes[dishes[,1]==k_for_t.new,3]) )
                M_k <- updateM_k(dishes,M_k,j,restaurants)
              }
              clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,2] <- t_c
              clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,3] <- restaurants[[j]][restaurants[[j]][,1]==t_c,2]
              clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,4] <- restaurants[[j]][restaurants[[j]][,1]==t_c,3]
              clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,5] <- restaurants[[j]][restaurants[[j]][,1]==t_c,4]
              pathways[[j]][[g]]$t[pathways[[j]][[g]]$c==c.m] <- t_c
              pathways[[j]][[g]]$k[pathways[[j]][[g]]$c==c.m] <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,3]
              pathways[[j]][[g]]$mu[pathways[[j]][[g]]$c==c.m] <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,4]
              pathways[[j]][[g]]$sigma_g[pathways[[j]][[g]]$c==c.m] <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,5]
              #update relevant parameters
              # if(init==1){
              #     taus.counts <- updataTauCounts2(taus,clusters,pathways)
              #     p.taus <- (taus.counts+1/length(taus))/(sum(taus.counts)+1)
              #   }
              # abcd <- update.abcd(clusters);a <- abcd$a;b <- abcd$b;c <- abcd$c;d <- abcd$d
            }
            #remove empty tables
            tables.to.remove <- setdiff(restaurants[[j]][,1],unique(unlist(sapply(pathways[[j]], function(g){g$t}))))
            if(length(tables.to.remove)>0){
              restaurants[[j]] <- restaurants[[j]][-which(restaurants[[j]][,1]%in% tables.to.remove),]
              if(is.vector(restaurants[[j]])){
                restaurants[[j]] <- matrix(data = restaurants[[j]],ncol =4)
                colnames(restaurants[[j]]) <- c("table","dish","mu","sigma")
              }
            }
            M_k <- updateM_k(dishes,M_k,j,restaurants)
            #remove unused dishes
            dishes.to.remove <- which(colSums(M_k)==0)
            if(length(dishes.to.remove)>0){
              M_k <- M_k[,-dishes.to.remove]
              dishes <- dishes[-dishes.to.remove,]
              if(is.vector(dishes)){
                dishes <- matrix(data = dishes,ncol = 3)
                colnames(dishes) <- c("k","mu","sigma")
                M_k <- matrix(data = M_k,nrow = J)
                colnames(M_k) <- dishes[,1]
              }
            }
          }
        }

        code.block = 3
        #updata k for t
        for(j in 1:J){
          if(nrow(restaurants[[j]])>0){
            for (i in 1:nrow(restaurants[[j]])) {
              t <- restaurants[[j]][i,1]
              L <- unlist(sapply(pathways[[j]], function(g){g$Lgm.hat[g$t==t]}))
              var.m <- unlist(sapply(pathways[[j]], function(g){g$var.gm[g$t==t]}))
              k_for_t <- kForNewTable4(j = j,dishes = dishes,L = L,var.m = var.m,taus = taus,p.taus =p.taus,M_k = M_k,alpha1_mu = alpha1_mu,alpha2_mu = alpha2_mu,w = w,p.w = p.w,p.00 = p.00,p.0 = p.0)
              #if k is new
              if(!(k_for_t%in%dishes[,1])){
                #sample a new parameter
                mu.sigma.new <- new.parameter(L = L,var.m = var.m,taus = taus,p.taus = p.taus,w = w,p.w = p.w,p.00 = p.00,p.0 = p.0)
                mu_new <- mu.sigma.new$mu;sigma_new <- mu.sigma.new$sigma
                dishes <- rbind(dishes, c(k_for_t,mu_new,sigma_new) )
              }
              restaurants[[j]][i,2] <- k_for_t
              restaurants[[j]][i,3] <- dishes[dishes[,1]==k_for_t,2]
              restaurants[[j]][i,4] <- dishes[dishes[,1]==k_for_t,3]
              M_k <- updateM_k(dishes,M_k,j,restaurants)
              #update model paremeters
              for (g in 1:length(pathways[[j]])) {
                #g <- 2
                if(sum(clusters[[j]][[g]][,2]==t)>0){
                  clusters[[j]][[g]][clusters[[j]][[g]][,2]==t,3] <- k_for_t
                  clusters[[j]][[g]][clusters[[j]][[g]][,2]==t,4] <- dishes[dishes[,1]==k_for_t,2]
                  clusters[[j]][[g]][clusters[[j]][[g]][,2]==t,5] <- dishes[dishes[,1]==k_for_t,3]
                  pathways[[j]][[g]]$k[pathways[[j]][[g]]$t==t] <- k_for_t
                  pathways[[j]][[g]]$mu[pathways[[j]][[g]]$t==t] <- dishes[dishes[,1]==k_for_t,2]
                  pathways[[j]][[g]]$sigma_g[pathways[[j]][[g]]$t==t] <- dishes[dishes[,1]==k_for_t,3]
                  #update relevant parameters
                  # if(init==1){
                  #     taus.counts <- updataTauCounts2(taus,clusters,pathways)
                  #     p.taus <- (taus.counts+1/length(taus))/(sum(taus.counts)+1)
                  #   }
                  # abcd <- update.abcd(clusters);a <- abcd$a;b <- abcd$b;c <- abcd$c;d <- abcd$d
                }
              }
            }
          }

        }
        #remove unused dishes
        dishes.to.remove <- which(colSums(M_k)==0)
        if(length(dishes.to.remove)>0){
          M_k <- M_k[,-dishes.to.remove]
          dishes <- dishes[-dishes.to.remove,]
          if(is.vector(dishes)){
            dishes <- matrix(data = dishes,ncol = 3)
            colnames(dishes) <- c("k","mu","sigma")
            M_k <- matrix(data = M_k,nrow = J)
            colnames(M_k) <- dishes[,1]
          }
        }
        code.block = 4
        if(iter>round(record/2)){
          #update p.outlier
          p.outlier <- (p.outlier.alpha+sum( PCHs[iter,] ))/(p.outlier.alpha+p.outlier.beta+ncol(PCHs))
          #update concentration parameters using grid
          if(updateAlpha==TRUE){
            if(iter>=record){
              Tj <- sapply(restaurants, function(j){nrow(j)})
              nj <- sapply(1:J, function(j){sum(sapply(clusters[[j]], function(g){nrow(g)}))})
              num.tabkes <- sum(Tj)
              num.dishes <- nrow(dishes)

              #super
              # p.alpha1 <- dgamma(x = alpha.grid,shape = alpha1.a,rate = alpha1.b)*alpha.grid^num.dishes*gamma(alpha.grid)/gamma(alpha.grid+num.tabkes)
              p.alpha1 <- alpha.grid^num.dishes*gamma(alpha.grid)/gamma(alpha.grid+num.tabkes)
              alpha1_mu <- sample(x = alpha.grid,size = 1,prob = p.alpha1)
              #sub
              # p.alpha2 <- sapply(1:length(alpha.grid), function(i){dgamma(x = alpha.grid[i],shape = alpha2.a,rate = alpha2.b)*alpha.grid[i]^num.tabkes* prod( gamma(alpha.grid[i])/gamma(alpha.grid[i]+nj) ) })
              p.alpha2 <- sapply(1:length(alpha.grid), function(i){alpha.grid[i]^num.tabkes* prod( gamma(alpha.grid[i])/gamma(alpha.grid[i]+nj) ) })
              alpha2_mu <- sample(x = alpha.grid,size = 1,prob = p.alpha2)
            }
          }
          #update p0 and p00
          num.spike <- 0
          num.mean0 <- 0
          num.path <- 0
          for (j in 1:J) {
            for (g in 1:length(pathways[[j]])) {
              k.g <- unique(pathways[[j]][[g]]$k);k.g <- k.g[k.g!=0]
              if(length(k.g)==1){
                num.path <- num.path + 1
                mu.g <- dishes[dishes[,1]==k.g,2];sigma.g <- dishes[dishes[,1]==k.g,3]
                if(mu.g==0){
                  if(sigma.g==0){
                    num.spike <- num.spike+1
                  }else{
                    num.mean0 <- num.mean0+1
                  }
                }
              }
            }
          }
          p.00 <- rbeta(n = 1,shape1 = 1+num.spike,shape2 = 1+num.path-num.spike)
          p.0 <- rbeta(n = 1,shape1 = 1+num.mean0,shape2 = 1+num.path-num.spike-num.mean0)
        }

        code.block = 5
        #update mus
        for (k in 1:nrow(dishes)) {
          #k <- 1
          k_mu <- dishes[k,1]
          meta.list <- select.all.metabolites(k_mu,pathways)
          mu.sigma.new <- new.parameter(L = meta.list$L.hat,var.m = meta.list$var.m,taus = taus,p.taus = p.taus,w = w,p.w = p.w,p.00 = p.00,p.0 = p.0)
          dishes[k,2] <- mu.sigma.new$mu;dishes[k,3] <- mu.sigma.new$sigma
        }
        for(j in 1:J){
          if(nrow(restaurants[[j]])>0){
            for (i in 1:nrow(restaurants[[j]])) {
              restaurants[[j]][i,3] <- dishes[dishes[,1]==restaurants[[j]][i,2],2]
              restaurants[[j]][i,4] <- dishes[dishes[,1]==restaurants[[j]][i,2],3]
            }
          }
          for (g in 1:length(pathways[[j]])) {
            for (c in clusters[[j]][[g]][,1]) {
              #update sigma_c
              k <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c,3]
              if(k%in%dishes[,1]){
                pathways[[j]][[g]]$mu[pathways[[j]][[g]]$c==c] <- dishes[which(dishes[,1]==k),2]
                pathways[[j]][[g]]$sigma_g[pathways[[j]][[g]]$c==c] <- dishes[which(dishes[,1]==k),3]
                clusters[[j]][[g]][clusters[[j]][[g]][,1]==c,4] <- dishes[which(dishes[,1]==k),2]
                clusters[[j]][[g]][clusters[[j]][[g]][,1]==c,5] <- dishes[which(dishes[,1]==k),3]
              }
            }
          }
        }
        #update relevant parameters
        # if(init==1){
        #     taus.counts <- updataTauCounts2(taus,clusters,pathways)
        #     p.taus <- (taus.counts+1/length(taus))/(sum(taus.counts)+1)
        # }
        abcd <- update.abcd(clusters=clusters,J=J);a <- abcd$a;b <- abcd$b;c <- abcd$c;d <- abcd$d

        code.block = 6
        if(iter>=record){
          mus <- vector()
          mu.g <- vector()
          sigma.g <- vector()
          k.sub <- vector()

          for (j in 1:J) {
            for (g in 1:length(pathways[[j]])) {
              k.g <- as.numeric(names(which.max(table(pathways[[j]][[g]][["k"]]))))
              k.sub <- c(k.sub,k.g)
              if(nrow(clusters[[j]][[g]])==0){
                #print(paste0(j,":",g))
                mus <- c(mus,pathways[[j]][[g]]$Lgm.hat)
                mu.g[pathways[[j]][[g]]$g] <- mean(pathways[[j]][[g]]$Lgm.hat)
                sigma.g[pathways[[j]][[g]]$g] <- sd(pathways[[j]][[g]]$Lgm.hat)
              }else{
                mus <- c(mus,rep(clusters[[j]][[g]][1,4],pathways[[j]][[g]]$Mg))
                mu.g[pathways[[j]][[g]]$g] <- clusters[[j]][[g]][1,4]
                sigma.g[pathways[[j]][[g]]$g] <- clusters[[j]][[g]][1,5]
              }
            }
          }
          Alphas.sup <- c(Alphas.sup,alpha1_mu);Alphas.sub <- c(Alphas.sub,alpha2_mu)
          Dishes[[iter-record+1]] <- dishes
          Dish.assign[[iter-record+1]] <- M_k
          Mus[iter-record+1,] <- mus
          Mu.g[iter-record+1,] <- mu.g
          Sigma.g[iter-record+1,] <- sigma.g
          p.0s <- c(p.0s,p.0);p.00s <- c(p.00s,p.0);p.out <- c(p.out,p.outlier)
          for (k.sub.i in unique(k.sub)) {
            Community[k.sub==k.sub.i,k.sub==k.sub.i] <- Community[k.sub==k.sub.i,k.sub==k.sub.i]+1
          }
        }
      }
    }
    result = list(K,k.latent,data,Mus,Mu.g,Sigma.g,Alphas.sup,Alphas.sub,PCHs,Dish.assign,Dishes,record,Iter,p.0s,p.00s,p.out,taus,p.taus,w,p.w,p.L,p.outlier.alpha,p.outlier.beta)
    names(result) = c("K","k.latent","data","Mus","Mu.g","Sigma.g","Alphas.sup","Alphas.sub","PCHs","Dish.assign","Dishes","record","Iter","p.0s","p.00s","p.out","taus","p.taus","w","p.w","p.L","p.outlier.alpha","p.outlier.beta")
    Result[[k.latent]] = result
    # save(list = c("K","k.latent","data","Mus","Mu.g","Sigma.g","Alphas.sup","Alphas.sub","PCHs","Dish.assign","Dishes","record","Iter","p.0s","p.00s","p.out","taus","p.taus","w","p.w","p.L","p.outlier.alpha","p.outlier.beta","max.miss"),file = paste0(saveFile,k.latent,".RData"))
  }
  return(Result)
}
